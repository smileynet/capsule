# Test Specification: Extract shared postPipeline helper from RunCmd

## Context
- Post-pipeline steps (merge worktree, cleanup, close bead) are shared between RunCmd and DashboardCmd
- Extract a postPipeline helper function that both commands can call
- RunCmd regression: must continue working after extraction
- DashboardCmd fires postPipeline as a tea.Cmd on return from summary mode
- Both tea.Cmds can be batched via tea.Batch
- Deliverable: shared postPipeline function, RunCmd refactor, DashboardCmd integration

## Test Cases

| Input | Expected Output | Notes |
|-------|-----------------|-------|
| postPipeline(ctx, opts) | Calls merge with correct worktree args | Merge invocation |
| postPipeline(ctx, opts) | Calls cleanup after merge | Cleanup invocation |
| postPipeline(ctx, opts) | Calls bead close with bead ID | Bead close invocation |
| RunCmd end-to-end | Still completes full pipeline + post steps | Regression test |
| DashboardCmd summary return | postPipeline fired as tea.Cmd | Dashboard integration |
| tea.Batch(postPipelineCmd, refreshCmd) | Both commands execute | Batch composition |
| postPipeline with passed pipeline | All three steps called in order | Happy path |
| postPipeline with failed pipeline | Merge skipped, cleanup + close still called | Fail path |

## Edge Cases
- [ ] Merge failure does not crash; error logged, cleanup proceeds
- [ ] Bead close failure logged but does not propagate fatal error
- [ ] postPipeline called with cancelled context returns early
- [ ] Concurrent postPipeline calls are safe (no shared mutable state)
