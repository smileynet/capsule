# Test Specification: Add sticky cursor and post-pipeline status line

## Bead: cap-fj8.4.4

## Tracer
Context preservation — proves return-to-browse experience is smooth.

## Context
- Track lastDispatchedID for cursor restoration
- Show status line for post-pipeline results with 5s timeout
- New statusClearMsg type

## Test Cases

| Input | Expected Output | Notes |
|-------|-----------------|-------|
| Dispatch bead "cap-xyz" | lastDispatchedID = "cap-xyz" | ID saved |
| Return to browse, BeadListMsg arrives | Cursor positioned on "cap-xyz" | Sticky cursor |
| "cap-xyz" not in new bead list | Cursor at position 0 (fallback) | Graceful fallback |
| PostPipelineDoneMsg success | statusMsg set, 5s tea.Tick started | Status shown |
| PostPipelineDoneMsg with error | statusMsg shows error text | Error feedback |
| statusClearMsg fires | statusMsg cleared, status line hidden | Auto-clear |
| Status line in view | Rendered between panes and help bar | Layout |
| 5s elapsed after status set | statusClearMsg fires | Timer works |

## Edge Cases
- [ ] Multiple PostPipelineDoneMsg (latest wins)
- [ ] Status line with very long error message (truncate)
- [ ] Return to browse with empty bead list
- [ ] statusClearMsg arrives after new pipeline started (ignore if mode != browse)

## Implementation Notes
- model gains: lastDispatchedID string, statusMsg string, statusExpiry time.Time
- On dispatch: set lastDispatchedID
- On returnToBrowse + BeadListMsg: find lastDispatchedID in bead list, set cursor
- On PostPipelineDoneMsg: set statusMsg, start tea.Tick(5 * time.Second)
- statusClearMsg: if time.Now().After(statusExpiry) → clear statusMsg
- Render: if statusMsg != "" → show styled line below panes
