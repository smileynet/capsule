# Test Specification: Implement debounced bead resolution

## Bead: cap-fj8.4.3

## Tracer
Responsiveness — prevents right-pane visual thrash.

## Context
- Extend model.go maybeResolve() with debounce logic
- Cache hits still show instantly (bypass debounce)
- New resolveDebounceMsg type

## Test Cases

| Input | Expected Output | Notes |
|-------|-----------------|-------|
| Cursor move to uncached bead | pendingResolveID set, 150ms tick started | Debounce active |
| 150ms tick fires, pendingResolveID unchanged | resolveBeadCmd fired | Resolution happens |
| Cursor moves again before tick | pendingResolveID updated, old tick cancelled | Cancel old |
| Cursor move to cached bead | Detail shown immediately, no debounce | Cache bypass |
| resolveDebounceMsg with stale ID | No resolution (ID changed) | Stale check |
| Rapid 5 cursor moves in 100ms | Only 1 resolve call (last bead) | Dedup works |

## Edge Cases
- [ ] Cursor moves to same bead twice (no double resolve)
- [ ] Debounce during mode transition (pipeline starts)
- [ ] Empty bead list (no resolve attempts)

## Implementation Notes
- model gains: pendingResolveID string, resolveDebounceSeq int
- On cursor move: set pendingResolveID, increment seq, start tea.Tick(150ms)
- resolveDebounceMsg carries seq number
- On resolveDebounceMsg: if seq matches current → fire resolveBeadCmd
- Cache check first: if cached, show immediately and skip debounce
