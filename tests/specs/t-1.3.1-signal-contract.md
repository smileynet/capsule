# TDD Spec: Define structured JSON signal contract

**Task:** t-1.3.1
**Feature:** Test-writer and test-review prompt pair
**Epic:** Epic 1 - Shell-based Pipeline Prototype

## Context

Define the signal JSON contract used by all phases to communicate results: {status, feedback, files_changed, summary}. Create parse-signal.sh that extracts the last JSON block from mixed claude output (which may contain markdown, code, and other text before the signal). Status values: PASS, NEEDS_WORK, ERROR.

## Test Cases

| # | Input / Setup | Expected Output | Notes |
|---|--------------|-----------------|-------|
| 1 | Parse output containing only valid signal JSON | Extracted JSON with status, feedback, files_changed, summary | Clean input case |
| 2 | Parse output with markdown text followed by signal JSON | Only the JSON block extracted, text discarded | Mixed output is the common case |
| 3 | Parse output with multiple JSON blocks | Last JSON block extracted (the signal) | Earlier JSON may be code examples |
| 4 | Parse output with no JSON block | Non-zero exit code, error message | Missing signal detection |
| 5 | Validate signal has required fields | Exit code 0 only if status field present | Partial JSON is invalid |
| 6 | Parse signal with status=NEEDS_WORK and non-empty feedback | feedback field accessible for retry injection | Feedback drives retry loop |

## Edge Cases

- [ ] JSON embedded in markdown code fences (```json ... ```) is still extractable
- [ ] Signal JSON containing nested objects or arrays in files_changed
- [ ] Very large claude output (>1MB) does not cause parse-signal.sh to fail
- [ ] Signal with unknown status value (not PASS/NEEDS_WORK/ERROR) is treated as ERROR

## Deliverable

Signal contract documentation + parse-signal.sh
