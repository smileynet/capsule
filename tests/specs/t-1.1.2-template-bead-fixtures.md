# TDD Spec: Create template bead fixtures (JSONL)

**Task:** t-1.1.2
**Feature:** Reusable template project with bead fixtures
**Epic:** Epic 1 - Shell-based Pipeline Prototype

## Context

Create templates/demo-brownfield/issues.jsonl with a bead hierarchy: 1 epic, 1 feature, 2 tasks with acceptance criteria. Each bead has id, title, description, type, priority, and dependencies. This fixture provides the structured work items that drive the pipeline through its phases.

## Test Cases

| # | Input / Setup | Expected Output | Notes |
|---|--------------|-----------------|-------|
| 1 | Parse each line of issues.jsonl as JSON | All lines parse as valid JSON objects | Each line must be independent valid JSON |
| 2 | Validate bead schema: id, title, description, type, priority, dependencies | All required fields present on every bead | No missing required fields |
| 3 | Count beads by type | 1 epic, 1 feature, 2 tasks | Exact hierarchy count |
| 4 | Validate task beads have acceptance criteria | Each task has non-empty acceptance_criteria field | Acceptance criteria drive test-writer phase |
| 5 | Run `bd import` with issues.jsonl on a fresh bd-initialized repo | Import succeeds, `bd ready` lists expected tasks | End-to-end bd compatibility |
| 6 | Validate dependency chain | Tasks depend on feature, feature depends on epic | Hierarchy is correctly wired |

## Edge Cases

- [ ] JSONL file has no trailing newline issues or empty lines that break parsing
- [ ] Bead IDs are unique across all entries
- [ ] Priority values are valid integers (0-4 range)
- [ ] Dependencies reference only IDs that exist in the same file

## Deliverable

issues.jsonl with 4 beads in epic-to-feature-to-task hierarchy
