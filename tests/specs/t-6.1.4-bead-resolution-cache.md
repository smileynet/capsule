# Test Specification: Async bead resolution, cache, and detail viewport

## Context
- Moving the cursor to a bead triggers asynchronous resolution of its full details
- A cache stores resolved bead details keyed by bead ID
- Cache hits skip the async resolve and render immediately
- The right pane displays resolved bead detail in a scrollable viewport
- Cache can be invalidated (e.g., after pipeline completes)
- Deliverable: resolve logic in browse.go, cache integration, viewport rendering

## Test Cases

| Input | Expected Output | Notes |
|-------|-----------------|-------|
| Cursor move to uncached bead | ResolveBeadCmd dispatched | Cache miss triggers resolve |
| Cursor move to cached bead | No ResolveBeadCmd, detail rendered | Cache hit skips resolve |
| Cache miss for "bead-1" | cache.Get("bead-1") returns nil, false | Verify cache state |
| ResolveBeadMsg success | Detail populated in viewport | Resolve success |
| ResolveBeadMsg failure | Error message in right pane | Resolve failure |
| cache.Invalidate() then cursor move | ResolveBeadCmd dispatched again | Invalidation forces re-resolve |
| Right pane focused, Down key | Viewport scrolls down | Viewport scroll |
| Right pane focused, PgUp | Viewport pages up | Viewport page scroll |
| Right pane focused, PgDn | Viewport pages down | Viewport page scroll |

## Edge Cases
- [ ] Rapid cursor movement (debounce): only last bead is resolved
- [ ] Resolve returns for a bead that is no longer selected (stale result ignored)
- [ ] Very long description text scrolls correctly in viewport
- [ ] Viewport resets scroll position when new bead detail is loaded
- [ ] Resolve timeout or cancellation handled gracefully
