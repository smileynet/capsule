# Test Specification: Add campaign types and CampaignRunner interface to dashboard

## Bead: cap-fj8.1.1

## Tracer
Foundation — defines the type system all other tasks depend on.

## Context
- Extend internal/dashboard/msg.go with campaign types
- Add BeadType to DispatchMsg
- Pass BeadType through browse dispatch

## Test Cases

| Input | Expected Output | Notes |
|-------|-----------------|-------|
| DispatchMsg{BeadID: "x", BeadType: "feature"} | BeadType field accessible | Type carried through |
| DispatchMsg{BeadID: "x", BeadType: ""} | Empty string (safe default) | Missing type is safe |
| ModeCampaign constant | Distinct from ModeBrowse, ModePipeline | No collision |
| ModeCampaignSummary constant | Distinct from ModeSummary | No collision |
| CampaignTaskInfo{ID, Title, Status} | All fields populated | Struct holds task data |
| CampaignRunner.RunCampaign(ctx, id, statusFn, campaignFn) | Method signature compiles | Interface defined |

## Edge Cases
- [ ] BeadType with unexpected values (not task/feature/epic)
- [ ] DispatchMsg with empty BeadID but populated BeadType
- [ ] CampaignTaskStatus transitions: pending → running → passed/failed

## Implementation Notes
- BeadSummary already has Type field — DispatchMsg just needs to carry it through
- browse.go line 89 creates DispatchMsg — needs BeadType: selected.Type
- CampaignRunner uses dual-callback pattern: statusFn for phases, campaignFn for lifecycle
